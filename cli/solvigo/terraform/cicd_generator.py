"""
CI/CD Terraform configuration generator
"""
from pathlib import Path
from typing import Dict, List
from jinja2 import Template
from rich.console import Console

console = Console()


def format_hcl_list(items: List[str]) -> str:
    """
    Convert Python list to HCL-compatible list format.

    Args:
        items: List of strings

    Returns:
        HCL list with double quotes (e.g., ["staging", "prod"])
    """
    if not items:
        return "[]"

    quoted_items = [f'"{item}"' for item in items]
    return '[' + ', '.join(quoted_items) + ']'


def generate_cicd_tf(
    client: str,
    project: str,
    platform_project_id: str,
    client_project_id: str,
    github_connection_id: str,
    github_repo_url: str,
    environments: List[str],
    output_dir: Path
) -> bool:
    """
    Generate cicd.tf file for Cloud Build pipeline.

    Args:
        client: Client name
        project: Project name
        platform_project_id: Platform project ID (where Cloud Build runs)
        client_project_id: Client project ID (where services are deployed)
        github_connection_id: GitHub connection ID from platform
        github_repo_url: GitHub repository URL
        environments: List of environments to create triggers for
        output_dir: Output directory for Terraform files

    Returns:
        True if successful, False otherwise
    """
    try:
        template = Template("""# CI/CD Pipeline Setup
# Generated by Solvigo CLI

# Get platform GitHub connection
data "terraform_remote_state" "platform_cloudbuild" {
  backend = "gcs"
  config = {
    bucket = "solvigo-platform-terraform-state"
    prefix = "cloud-build"
  }
}

# Setup CI/CD pipeline
module "cicd" {
  source = "../.terraform-modules/platform/cloud-build-pipeline"

  client_name         = "{{ client }}"
  project_name        = "{{ project }}"
  platform_project_id = "{{ platform_project_id }}"
  client_project_id   = var.project_id

  github_connection_id = data.terraform_remote_state.platform_cloudbuild.outputs.github_connection_id
  github_repo_url      = "{{ github_repo_url }}"

  region       = var.region
  environments = {{ environments }}
}

# Outputs for CI/CD resources
output "cicd_deployer_sa" {
  description = "Service account used by Cloud Build for deployments"
  value       = module.cicd.deployer_sa_email
}

output "cicd_artifact_registry" {
  description = "Artifact Registry repository URL for Docker images"
  value       = module.cicd.artifact_registry_url
}

output "cicd_trigger_ids" {
  description = "Cloud Build trigger IDs by environment"
  value       = module.cicd.trigger_ids
}

output "cicd_trigger_names" {
  description = "Cloud Build trigger names by environment"
  value       = module.cicd.trigger_names
}
""")

        content = template.render(
            client=client,
            project=project,
            platform_project_id=platform_project_id,
            github_repo_url=github_repo_url,
            environments=format_hcl_list(environments)  # Convert to HCL format with double quotes
        )

        cicd_file = output_dir / 'cicd.tf'
        cicd_file.write_text(content)

        console.print(f"  ‚úì Created cicd.tf")
        return True

    except Exception as e:
        console.print(f"[red]‚úó Error generating cicd.tf: {e}[/red]")
        return False


def generate_cloudbuild_yaml(
    service_name: str,
    service_type: str,
    dockerfile_path: str,
    client: str,
    project: str,
    output_dir: Path
) -> bool:
    """
    Generate cloudbuild.yaml file for Cloud Build.

    Args:
        service_name: Cloud Run service name
        service_type: 'backend' or 'frontend'
        dockerfile_path: Path to Dockerfile
        client: Client name
        project: Project name
        output_dir: Output directory

    Returns:
        True if successful, False otherwise
    """
    try:
        # Extract directory path from Dockerfile path
        dockerfile_dir = str(Path(dockerfile_path).parent) if Path(dockerfile_path).parent != Path('.') else '.'

        template = Template("""# Cloud Build Configuration for {{ client }}/{{ project }} - {{ service_name }}
# Generated by Solvigo CLI
#
# This file defines the CI/CD pipeline for deploying your application.
# Triggered by: Git pushes/tags (see Cloud Build triggers)
#
# Substitutions available:
#   _CLIENT_NAME      - Client name
#   _PROJECT_NAME     - Project name
#   _ENVIRONMENT      - Environment (dev/staging/prod)
#   _REGION           - GCP region
#   _GCP_PROJECT      - Target GCP project ID
#   _SERVICE_ACCOUNT  - Deployer service account
#   _ARTIFACT_REPO    - Artifact Registry repository URL

options:
  machineType: 'E2_HIGHCPU_8'
  logging: CLOUD_LOGGING_ONLY
  substitutionOption: ALLOW_LOOSE

# Timeout after 20 minutes
timeout: '1200s'

substitutions:
  _SERVICE_NAME: '{{ service_name }}'
  _IMAGE_TAG: '$SHORT_SHA'
  _DOCKERFILE_DIR: '{{ dockerfile_dir }}'

steps:
  # Step 1: Build Docker image
  - name: 'gcr.io/cloud-builders/docker'
    id: 'build-image'
    args:
      - 'build'
      - '--cache-from'
      - '$_ARTIFACT_REPO/$_SERVICE_NAME:latest'
      - '-t'
      - '$_ARTIFACT_REPO/$_SERVICE_NAME:$_IMAGE_TAG'
      - '-t'
      - '$_ARTIFACT_REPO/$_SERVICE_NAME:latest'
      - '-t'
      - '$_ARTIFACT_REPO/$_SERVICE_NAME:$_ENVIRONMENT'
      - '-f'
      - '{{ dockerfile_path }}'
      - '$_DOCKERFILE_DIR'
    timeout: '600s'

  # Step 2: Push image to Artifact Registry
  - name: 'gcr.io/cloud-builders/docker'
    id: 'push-image'
    args:
      - 'push'
      - '--all-tags'
      - '$_ARTIFACT_REPO/$_SERVICE_NAME'
    waitFor: ['build-image']
    timeout: '300s'

  # Step 3: Deploy to Cloud Run
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'deploy-cloudrun'
    entrypoint: gcloud
    args:
      - 'run'
      - 'deploy'
      - '$_SERVICE_NAME'
      - '--image=$_ARTIFACT_REPO/$_SERVICE_NAME:$_IMAGE_TAG'
      - '--region=$_REGION'
      - '--platform=managed'
      - '--project=$_GCP_PROJECT'
      - '--allow-unauthenticated'{% if service_type == 'backend' %}
      # Backend-specific settings
      # Uncomment and customize as needed:
      # - '--vpc-connector=solvigo-vpc-connector'
      # - '--set-cloudsql-instances=$_DB_INSTANCE'
      # - '--set-env-vars=ENV=$_ENVIRONMENT'
      # - '--set-secrets=DB_PASSWORD=db-password:latest,API_KEY=api-key:latest'
      # - '--max-instances=10'
      # - '--min-instances=0'
      # - '--cpu=1'
      # - '--memory=512Mi'{% elif service_type == 'frontend' %}
      # Frontend-specific settings
      # Uncomment and customize as needed:
      # - '--set-env-vars=REACT_APP_API_URL=https://api.$_DOMAIN'
      # - '--max-instances=5'
      # - '--min-instances=0'
      # - '--cpu=1'
      # - '--memory=256Mi'{% endif %}
    waitFor: ['push-image']
    timeout: '300s'

  # Step 4 (Optional): Run smoke tests
  # Uncomment to enable:
  # - name: 'gcr.io/cloud-builders/curl'
  #   id: 'smoke-test'
  #   args:
  #     - '-f'  # Fail on HTTP errors
  #     - 'https://$_SERVICE_NAME-$_ENVIRONMENT.{{ domain }}/health'
  #   waitFor: ['deploy-cloudrun']

# Images to track in build history
images:
  - '$_ARTIFACT_REPO/$_SERVICE_NAME:$_IMAGE_TAG'
  - '$_ARTIFACT_REPO/$_SERVICE_NAME:latest'
  - '$_ARTIFACT_REPO/$_SERVICE_NAME:$_ENVIRONMENT'
""")

        # Generate domain for smoke tests
        client_slug = client.lower().replace(' ', '-')
        domain = f"{client_slug}.solvigo.ai"

        content = template.render(
            service_name=service_name,
            service_type=service_type,
            dockerfile_path=dockerfile_path,
            dockerfile_dir=dockerfile_dir,
            client=client,
            project=project,
            domain=domain
        )

        # Determine output filename
        if service_type in ['backend', 'frontend']:
            filename = f"cloudbuild-{service_type}.yaml"
        else:
            filename = "cloudbuild.yaml"

        build_file = output_dir / filename
        build_file.write_text(content)

        console.print(f"  ‚úì Created {filename}")
        return True

    except Exception as e:
        console.print(f"[red]‚úó Error generating cloudbuild.yaml: {e}[/red]")
        return False


def generate_all_cicd_files(
    client: str,
    project: str,
    platform_project_id: str,
    client_project_id: str,
    github_connection_id: str,
    github_repo_url: str,
    services: List[Dict],
    environments: List[str],
    terraform_dir: Path,
    app_dir: Path = None
) -> bool:
    """
    Generate all CI/CD files (cicd.tf and cloudbuild.yaml files).

    Args:
        client: Client name
        project: Project name
        platform_project_id: Platform project ID
        client_project_id: Client project ID
        github_connection_id: GitHub connection ID
        github_repo_url: GitHub repository URL
        services: List of service configurations
        environments: List of environments
        terraform_dir: Terraform directory
        app_dir: Application directory (for cloudbuild.yaml files)

    Returns:
        True if all files generated successfully
    """
    console.print("\n[cyan]üìù Generating CI/CD configuration...[/cyan]\n")

    # Generate cicd.tf
    success = generate_cicd_tf(
        client=client,
        project=project,
        platform_project_id=platform_project_id,
        client_project_id=client_project_id,
        github_connection_id=github_connection_id,
        github_repo_url=github_repo_url,
        environments=environments,
        output_dir=terraform_dir
    )

    if not success:
        return False

    # Generate cloudbuild.yaml files
    # Default to terraform_dir parent if app_dir not provided
    if app_dir is None:
        app_dir = terraform_dir.parent / 'app'
        app_dir.mkdir(parents=True, exist_ok=True)

    for service in services:
        success = generate_cloudbuild_yaml(
            service_name=service['name'],
            service_type=service['type'],
            dockerfile_path=service['dockerfile'],
            client=client,
            project=project,
            output_dir=app_dir
        )
        if not success:
            return False

    console.print(f"\n[green]‚úì CI/CD configuration generated successfully[/green]\n")
    console.print(f"[dim]Terraform:[/dim] {terraform_dir / 'cicd.tf'}")
    console.print(f"[dim]Build configs:[/dim] {app_dir}/cloudbuild*.yaml\n")

    return True
